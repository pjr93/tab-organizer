<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Robust Adaptive Grid Groups with Reordering & Unique IDs</title>
    <style>
        body {
            font-family: sans-serif;
            background: #f8f9fb;
            margin: 0;
        }

        h2 {
            margin: 20px 0 0 24px;
        }

        #parent-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            padding: 32px;
        }

        .child-grid {
            background: #fff;
            border: 2px solid #666;
            border-radius: 8px;
            min-width: 180px;
            min-height: 80px;
            box-shadow: 0 2px 6px #0001;
            padding: 16px 10px 16px 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            position: relative;
            transition: box-shadow 0.16s, border-color 0.16s;
        }

        .child-grid.dragover {
            border-color: #2196F3;
            box-shadow: 0 0 0 3px #cce7ff;
        }

        .grid-item {
            background: #59c96e;
            color: white;
            border-radius: 6px;
            min-width: 70px;
            min-height: 37px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            position: relative;
            cursor: move;
            user-select: none;
            font-weight: bold;
            gap: 6px;
        }

        .grid-item.dragging {
            opacity: 0.5;
        }

        .delete-btn {
            display: none;
            position: absolute;
            top: 3px;
            right: 7px;
            background: #e53e3e;
            border: none;
            color: #fff;
            font-weight: bold;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 16px;
            line-height: 15px;
            padding: 0;
        }

        .grid-item:hover .delete-btn {
            display: block;
        }

        .group-delete-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 22px;
            height: 22px;
            background: #e53e3e;
            border: none;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 20px;
            user-select: none;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 10;
            transition: opacity 0.2s ease;
        }

        .group-delete-btn:hover {
            background: #b32b2b;
        }

        .child-grid:hover>.group-delete-btn {
            display: flex;
            opacity: 1;
        }

        .placeholder {
            box-sizing: border-box;
            min-height: 37px;
            width: 70px;
            margin: 4px 0;
            background: #90caf9;
            border: 2px dashed #2196F3;
            border-radius: 6px;
        }

        #drop-indicator {
            position: fixed;
            pointer-events: none;
            z-index: 90;
            background: #2196F3cc;
            color: #fff;
            border-radius: 8px;
            font-weight: bold;
            padding: 10px 24px;
            font-size: 18px;
            box-shadow: 0 4px 28px #2196F366;
            display: none;
        }

        #outside-overlay {
            display: none;
            position: fixed;
            z-index: 80;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(33, 150, 243, 0.08);
            pointer-events: none;
        }

        #outside-overlay.active {
            display: block;
            pointer-events: all;
        }
    </style>
</head>

<body>
    <h2>Robust Adaptive Board with Unique IDs & Reordering</h2>
    <button style="margin: 14px 0 0 26px;" onclick="addDemoItem()">Add Random Item to First Group</button>

    <div id="parent-grid"></div>
    <div id="outside-overlay"></div>
    <div id="drop-indicator">Drop here to create a new group</div>

    <script>
        const parentGrid = document.getElementById('parent-grid');
        const dropIndicator = document.getElementById('drop-indicator');
        const outsideOverlay = document.getElementById('outside-overlay');

        let draggedItem = null;     // The DOM element being dragged
        let draggedId = null;       // The unique id of dragged item
        let placeholder = null;     // Placeholder element showing drop position
        let nextItemId = 1;         // Global unique id counter

        // Initial data: groups with items as objects {id, text}
        let groupData = [
            [{ id: nextItemId++, text: "Alpha" }, { id: nextItemId++, text: "Beta" }],
            [{ id: nextItemId++, text: "Gamma" }, { id: nextItemId++, text: "Delta" }, { id: nextItemId++, text: "Epsilon" }],
            [{ id: nextItemId++, text: "Zeta" }],
        ];

        // Clear existing placeholder if any
        function clearPlaceholder() {
            if (placeholder && placeholder.parentElement) {
                placeholder.parentElement.removeChild(placeholder);
                placeholder = null;
            }
        }

        // Find nearest item element in flex-wrap container for insertion logic
        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.grid-item:not(.dragging)')];

            // Will hold the element just after the pointer
            let afterElement = null;

            // Keep track of minimum distance to decide the "closest after"
            let minDistance = Infinity;

            for (const child of draggableElements) {
                const box = child.getBoundingClientRect();

                // Check if pointer is within vertical extent of the child element (same "row")
                if (y >= box.top && y <= box.bottom) {
                    // Pointer horizontal relative to child
                    const offset = x - box.left;

                    // If pointer is to the left of element start, it's candidate for insertion before the element
                    if (offset < 0 && Math.abs(offset) < minDistance) {
                        minDistance = Math.abs(offset);
                        afterElement = child;
                    }
                }
            }

            // If none found in same row, check for first element below the pointer vertically
            if (!afterElement) {
                for (const child of draggableElements) {
                    const box = child.getBoundingClientRect();

                    if (box.top > y) {
                        // closer vertical element below pointer
                        const dist = box.top - y;
                        if (dist < minDistance) {
                            minDistance = dist;
                            afterElement = child;
                        }
                    }
                }
            }

            // return element before which to insert, or null for append
            return afterElement;
        }

        function createGroup(items = [], idx) {
            const group = document.createElement('div');
            group.className = 'child-grid';
            group.dataset.group = idx;

            group.addEventListener('dragover', e => {
                e.preventDefault();
                group.classList.add('dragover');
                if (!draggedItem) return;

                const afterElement = getDragAfterElement(group, e.clientX, e.clientY);
                clearPlaceholder();

                // Create placeholder with same size as dragged item
                placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                placeholder.style.minHeight = draggedItem.offsetHeight + 'px';
                placeholder.style.width = draggedItem.offsetWidth + 'px';

                if (afterElement == null) {
                    group.appendChild(placeholder);
                } else {
                    group.insertBefore(placeholder, afterElement);
                }
            });

            group.addEventListener('dragleave', e => {
                if (e.relatedTarget && !group.contains(e.relatedTarget)) {
                    group.classList.remove('dragover');
                    clearPlaceholder();
                }
            });

            group.addEventListener('drop', e => {
                e.preventDefault();
                group.classList.remove('dragover');

                if (!draggedItem || draggedId === null) return;

                const itemObj = getItemById(draggedId);
                if (!itemObj) {
                    hideDropIndicator();
                    deactivateOutsideOverlay();
                    return;
                }

                removeFromGroupData(draggedId);

                // Filter for only grid items and placeholder to calculate an accurate index
                const childrenArray = Array.from(group.children).filter(ch =>
                    ch.classList.contains('grid-item') || ch === placeholder
                );

                let newIndex = placeholder && placeholder.parentElement === group
                    ? childrenArray.indexOf(placeholder)
                    : childrenArray.length;

                clearPlaceholder();

                groupData[idx].splice(newIndex, 0, itemObj);

                renderBoard();

                hideDropIndicator();
                deactivateOutsideOverlay();
            });

            // Add group delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'group-delete-btn';
            deleteBtn.textContent = '×';
            deleteBtn.title = "Delete this group";
            deleteBtn.addEventListener('click', e => {
                e.stopPropagation();
                groupData.splice(idx, 1);
                renderBoard();
            });
            group.appendChild(deleteBtn);

            // Add items to group
            for (const itemObj of items) {
                group.appendChild(createGridItem(itemObj));
            }

            return group;
        }

        function createGridItem(itemObj) {
            const item = document.createElement('div');
            item.className = 'grid-item';
            item.textContent = itemObj.text;
            item.draggable = true;
            item.dataset.id = itemObj.id;

            const btn = document.createElement('button');
            btn.className = 'delete-btn';
            btn.textContent = '×';
            btn.onclick = e => {
                e.stopPropagation();
                removeFromGroupData(itemObj.id);
                renderBoard();
            };
            item.appendChild(btn);

            item.addEventListener('dragstart', e => {
                draggedItem = item;
                draggedId = itemObj.id;
                item.classList.add('dragging');
                setTimeout(() => { item.style.display = 'none'; }, 0);
                document.addEventListener('dragover', onDragAnywhere);
            });

            item.addEventListener('dragend', e => {
                draggedItem = null;
                draggedId = null;
                item.style.display = '';
                item.classList.remove('dragging');
                hideDropIndicator();
                deactivateOutsideOverlay();
                clearPlaceholder();
                document.removeEventListener('dragover', onDragAnywhere);
            });

            return item;
        }

        function removeFromGroupData(id) {
            for (const group of groupData) {
                const index = group.findIndex(item => item.id === id);
                if (index !== -1) {
                    group.splice(index, 1);
                    break;
                }
            }
        }

        function getItemById(id) {
            for (const group of groupData) {
                for (const item of group) {
                    if (item.id === id) return item;
                }
            }
            return null;
        }

        function onDragAnywhere(ev) {
            const grids = Array.from(document.elementsFromPoint(ev.clientX, ev.clientY))
                .filter(e => e.classList && e.classList.contains('child-grid'));

            if (grids.length === 0 && draggedItem) {
                showDropIndicator(ev.clientX, ev.clientY);
                activateOutsideOverlay();
            } else {
                hideDropIndicator();
                deactivateOutsideOverlay();
            }
        }

        function showDropIndicator(x, y) {
            dropIndicator.style.display = 'block';
            dropIndicator.style.left = (x + 14) + 'px';
            dropIndicator.style.top = (y - 28) + 'px';
        }

        function hideDropIndicator() {
            dropIndicator.style.display = 'none';
        }

        function activateOutsideOverlay() {
            outsideOverlay.classList.add('active');
        }

        function deactivateOutsideOverlay() {
            outsideOverlay.classList.remove('active');
        }

        outsideOverlay.addEventListener('dragenter', e => e.preventDefault());
        outsideOverlay.addEventListener('dragover', e => e.preventDefault());
        outsideOverlay.addEventListener('drop', ev => {
            ev.preventDefault();
            if (!draggedItem || draggedId == null) return;
            const itemObj = getItemById(draggedId);
            if (!itemObj) return;
            removeFromGroupData(draggedId);
            groupData.push([itemObj]);
            renderBoard();
            hideDropIndicator();
            deactivateOutsideOverlay();
        });

        function renderBoard() {
            parentGrid.innerHTML = '';
            groupData = groupData.filter(g => g.length);
            groupData.forEach((items, idx) => parentGrid.appendChild(createGroup(items, idx)));
        }

        window.addDemoItem = function () {
            if (groupData.length === 0) groupData.push([]);
            groupData[0].push({ id: nextItemId++, text: 'Random' + Math.floor(Math.random() * 90 + 10) });
            renderBoard();
        };

        renderBoard();
    </script>
</body>

</html>